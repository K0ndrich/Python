# Функция Super

# Позволяет обращаться к родительскому классу и вызывает его методы в дочерных классах наследниках, имено в классах а не в обектах
# Позволяет не переопредилять метод в дочерних классах, а использовать существуюущий из родительского класса

# Делегирование - когда дочерный класс вызывает методы из родительского класса и добавляет плюс еще свой функционал


class MyClass1:

    name = "MyClass1"

    def __init__(self, a, b):
        # self.__class__ возвразает название класса который вызвался, даже может быть класс наследник
        print(f"- INIT {self.__class__} -")
        self.a = a
        self.b = b


class MyClass2(MyClass1):

    # метод рисует что-то
    def draw(self):
        print("- DRAW MyClass2-")


class MyClass3(MyClass1):

    def __init__(self, a, b, c):
        # вызов инициализатора __init__ из родительского класса MyClass1
        # MyClass1.__init__(self, a, b)

        # но лучше обращаться к родительскому классу через функцию super() потому, что название родительского класса может поменяться
        # super() всегда нужно вызывать с самого начала работы метода вверху
        super().__init__(a, b)

        self.c = c


my_object = MyClass3(4, 6, 8)  # -> - INIT <class '__main__.MyClass3'> -

my_object.__dict__  # -> {'a': 4, 'b': 6, 'c': 8}


# 1) -----   ПРИМЕР   -------------------------------------------------------------------------------------------------------------------


# my_object -> B.start_init -> A.init -> B.end_init


class A:
    def __init__(self, a):
        self.a = a


class B(A):
    def __init__(self, a, b):
        super().__init__(a)
        self.b = b


my_object = B(3, 5)
my_object.a, my_object.b  # -> 3 , 5
