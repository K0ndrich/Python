# Продвинутая Функция ZIP

# Позвоялет обращаться сразу к двом последовательностям по одному значению индекса

# zip(my_iterable_object1 , my_iterable_object2 , my_iterable_object2 , ..... )  # -> zip object


# 1) -----   ПРИМЕР   ----------------------------------------------------------------------------------------------------------------------------------------------------------

my_numbers1 = [4, 5, 6, 7]

my_numbers2 = [100, 200, 300, 400]


# for i in range(4):
#     print(my_numbers1[i], my_numbers2[i], sep="->")  # -> 4->100 , 5->200 , 6->300 , 7->400


# 2) -----   ПРИМЕР   ----------------------------------------------------------------------------------------------------------------------------------------------------------

# Одинаковое количество елементов в двох последовательностях
my_numbers1 = [4, 5, 6, 7]

my_numbers2 = [100, 200, 300, 400]

zip(my_numbers1, my_numbers2)  # -> <zip object at 0x0000017BC5FF9640>

list(zip(my_numbers1, my_numbers2))  # -> [(4, 100), (5, 200), (6, 300), (7, 400)]


# 3) -----   ПРИМЕР   ----------------------------------------------------------------------------------------------------------------------------------------------------------


# НЕ Одинаковое количество елементов в двох последовательностях
my_numbers1 = [4, 5, 6, 7, 9, 1, 3, 6, 2, 8]

my_numbers2 = [100, 200, 300, 400]

zip(my_numbers1, my_numbers2)  # -> <zip object at 0x0000017BC5FF9640>

# функция zip не видает ошибку, а просто не берет во внимание остальные числа
list(zip(my_numbers1, my_numbers2))  # -> [(4, 100), (5, 200), (6, 300), (7, 400)]


# 4) -----   ПРИМЕР   ----------------------------------------------------------------------------------------------------------------------------------------------------------

# здесь функция zip принимает разу три последовательности

my_numbers1 = [5, 6, 7, 8, 4]
my_numbers2 = [100, 200, 300, 400, 500]
my_str = "kondrich"

result = list(zip(my_numbers1, my_numbers2, my_str))

result  # -> [(5, 100, 'k'), (6, 200, 'o'), (7, 300, 'n'), (8, 400, 'd'), (4, 500, 'r')]

for i in zip(my_numbers1, my_numbers2, my_str):

    i  # -> (5, 100, 'k') , (6, 200, 'o') , (7, 300, 'n') , (8, 400, 'd') , (4, 500, 'r')


for element1, element2, element3 in zip(my_numbers1, my_numbers2, my_str):

    element1  # -> 5 , 6 , 7 , 8 , 4
    element2  # -> 100 , 200 , 300 , 400 , 500
    element3  # -> k , o , n , d , r


# 5) -----   ПРИМЕР   ----------------------------------------------------------------------------------------------------------------------------------------------------------

# розпаковываем значение функции zip назад в начальные наборы последовательностей

my_numbers1 = [5, 6, 7, 8, 4]
my_numbers2 = [100, 200, 300, 400, 500]
my_str = "kondrich"


result = zip(my_numbers1, my_numbers2, my_str)

element1, element2, element3 = zip(*result)

element1  # -> (5, 6, 7, 8, 4)
element2  # -> (100, 200, 300, 400, 500)
element3  # -> ('k', 'o', 'n', 'd', 'r')


# -----   ОШИБКИ   ----------------------------------------------------------------------------------------------------------------------------------------------------------

# ошибки при работе с функцией zip

my_numbers1 = [5, 6, 7, 8]
my_numbers2 = [100, 200, 300, 400]


# нельзя использовать функцию len для итераторов
# len(zip(my_numbers1, my_numbers2))  # -> Error


# нельзя получать значения по индексу в итераторов
# result = zip(my_numbers1, my_numbers2)
# result[1]  # -> Error


# значения в итераторе можно обходить только один раз, второй раз он ничего не будет возвращать
# после первого обхода все значения в итераторе заканчиваються
result = zip(my_numbers1, my_numbers2)
for i in result:
    i  # -> (5, 100) , (6, 200) , (7, 300) , (8, 400)


for i in result:
    i  # -> NOTHING
